<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Permaculture Library Concept Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
        }

        button {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            color: #2c3e50;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        button:hover {
            background: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        button.active {
            background: #27ae60;
            color: white;
        }

        /* Material Callouts (Labels) */
        .label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #e67e22; /* Copper/Pine accent */
        }

        .label::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.8) transparent transparent transparent;
        }

        .label.visible { opacity: 1; }

        #title-card {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        h1 { margin: 0; font-size: 24px; font-weight: 300; }
        h2 { margin: 0; font-size: 14px; opacity: 0.8; font-weight: 400; }

        /* Book Info Panel */
        #book-info-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 9999;
            display: none; /* Hidden by default */
            border: 1px solid #e67e22;
        }
        #book-info-panel h3 { margin-top: 0; }
        #book-info-panel p { font-size: 14px; }
        #book-info-panel .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
        }
    </style>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Tweening for smooth camera movement -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="title-card">
        <h1>Permaculture Library</h1>
        <h2>Low-Poly Concept Model</h2>
    </div>

    <div id="ui-layer">
        <button onclick="moveCamera('front')" id="btn-front">Exterior Front</button>
        <button onclick="moveCamera('aerial')" id="btn-aerial">Exterior Aerial</button>
        <button onclick="moveCamera('hall')" id="btn-hall">Main Hall</button>
        <button onclick="moveCamera('station')" id="btn-station">Maker Station</button>
        <button onclick="toggleLabels()" id="btn-labels">Toggle Material Callouts</button>
    </div>

    <!-- Labels container -->
    <div id="labels-container"></div>

    <!-- Book Info Panel -->
    <div id="book-info-panel">
        <div class="close-btn" onclick="hideBookInfo()">X</div>
        <h3 id="book-title"></h3>
        <p>by <span id="book-author"></span></p>
        <img id="book-cover" src="" alt="Book Cover" style="width: 100%;">
        <p id="book-description"></p>
        <button id="download-btn">Download</button>
        <button id="donate-btn">Donate</button>
    </div>

    <!-- Shelf Index Panel -->
    <div id="shelf-index-panel" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 1001; border: 1px solid #e67e22;">
        <div class="close-btn" onclick="hideShelfIndex()">X</div>
        <h3 id="shelf-category"></h3>
        <ul id="shelf-book-list"></ul>
    </div>

    <!-- Front Desk Index Panel -->
    <div id="front-desk-panel" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; max-height: 80vh; overflow-y: auto; background: rgba(0,0,0,0.85); color: white; padding: 25px; border-radius: 10px; z-index: 1002; border: 1px solid #e67e22;">
        <div class="close-btn" onclick="hideFrontDeskIndex()">X</div>
        <h3>Library Index</h3>
        <div id="front-desk-book-list"></div>
    </div>

    <div id="canvas-container"></div>

<script>
    // --- Configuration ---
    let scene, camera, renderer, controls;
    let labels = [];
    let showLabels = false;
    let clickableObjects = []; // For raycasting

    // --- Mock Book Database ---
    const booksDB = [
        // Shelf 1: Manuals
        {
            id: '978-0938250024',
            title: 'Permaculture: A Designers’ Manual',
            author: 'Bill Mollison',
            description: 'The definitive manual for permaculture design, covering ethics, principles, and strategies.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/8265147-L.jpg',
            category: 'Manuals', donationLink: '#'
        },
        {
            id: '978-1933392848',
            title: 'Gaia\'s Garden: A Guide to Home-Scale Permaculture',
            author: 'Toby Hemenway',
            description: 'A practical guide to applying permaculture principles in a backyard garden.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/8734363-L.jpg',
            category: 'Manuals', donationLink: '#'
        },
        {
            id: '978-1603580292',
            title: 'The Resilient Farm and Homestead',
            author: 'Ben Falk',
            description: 'An innovative permaculture and regenerative design approach for farm and homestead.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/7183499-L.jpg',
            category: 'Manuals', donationLink: '#'
        },
        // Shelf 2: Science
        {
            id: '978-0865717355',
            title: 'Teaming with Microbes',
            author: 'Jeff Lowenfels & Wayne Lewis',
            description: 'An organic gardener\'s guide to the soil food web.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/10469854-L.jpg',
            category: 'Science', donationLink: '#'
        },
        {
            id: '978-1603587932',
            title: 'The Hidden Life of Trees',
            author: 'Peter Wohlleben',
            description: 'What They Feel, How They Communicate—Discoveries from a Secret World.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/8279509-L.jpg',
            category: 'Science', donationLink: '#'
        },
         {
            id: '978-0199252723',
            title: 'Entangled Life',
            author: 'Merlin Sheldrake',
            description: 'How Fungi Make Our Worlds, Change Our Minds & Shape Our Futures.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/10255655-L.jpg',
            category: 'Science', donationLink: '#'
        },
        // Shelf 3: History
        {
            id: '978-1400065804',
            title: 'Sapiens: A Brief History of Humankind',
            author: 'Yuval Noah Harari',
            description: 'A sweeping overview of the history of our species.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/8372221-L.jpg',
            category: 'History', donationLink: '#'
        },
        {
            id: '978-1550135650',
            title: 'Cod: A Biography of the Fish that Changed the World',
            author: 'Mark Kurlansky',
            description: 'The biography of a single fish species, illustrating its dramatic impact on history.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/10041477-L.jpg',
            category: 'History', donationLink: '#'
        },
        {
            id: '978-0143118742',
            title: '1491: New Revelations of the Americas Before Columbus',
            author: 'Charles C. Mann',
            description: 'A groundbreaking look at the civilizations of the Americas before European contact.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/9207865-L.jpg',
            category: 'History', donationLink: '#'
        },
        // Shelf 4: Spiritual
        {
            id: '978-1577314806',
            title: 'The Power of Now',
            author: 'Eckhart Tolle',
            description: 'A guide to spiritual enlightenment, focusing on living in the present moment.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/8273299-L.jpg',
            category: 'Spiritual', donationLink: '#'
        },
        {
            id: '978-1603580292',
            title: 'The One-Straw Revolution',
            author: 'Masanobu Fukuoka',
            description: 'A classic work about natural farming and the spiritual philosophy behind it.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/10186091-L.jpg',
            category: 'Spiritual', donationLink: '#'
        },
        {
            id: '978-0140194721',
            title: 'Tao Te Ching',
            author: 'Lao Tzu',
            description: 'An ancient Chinese text offering a path of harmony and balance in the universe.',
            content: '#', coverImage: 'https://covers.openlibrary.org/b/id/8263598-L.jpg',
            category: 'Spiritual', donationLink: '#'
        },
    ];


    // Materials
    const materials = {
        pine: new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 0.8, name: "Pine Wood" }),
        glass: new THREE.MeshPhysicalMaterial({
            color: 0x88CCFF,
            transparent: true,
            opacity: 0.3,
            roughness: 0,
            metalness: 0.1,
            transmission: 0.9, // Glass-like
            thickness: 0.5,
            name: "Glass"
        }),
        copper: new THREE.MeshStandardMaterial({ color: 0x43B3AE, roughness: 0.6, metalness: 0.5, name: "Weathered Copper" }), // Weathered patina color
        grass: new THREE.MeshStandardMaterial({ color: 0x55aa55, roughness: 1.0 }),
        floor: new THREE.MeshStandardMaterial({ color: 0xC19A6B, roughness: 0.5 }), // Polished wood floor
        white: new THREE.MeshStandardMaterial({ color: 0xffffff }),
        screen: new THREE.MeshBasicMaterial({ color: 0x333333 })
    };

    function init() {
        // Scene Setup
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        // Camera
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 15, 30); // Default view

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 5, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        scene.add(sunLight);

        // --- Build The Library ---
        createEnvironment();
        createBuilding();

        // --- Labels Setup ---
        createLabel("Pine Wood Structure", new THREE.Vector3(6, 4, 6));
        createLabel("Weathered Copper Trim", new THREE.Vector3(0, 9.5, 5));
        createLabel("Arched Glass Windows", new THREE.Vector3(0, 4, 6.2));
        createLabel("Terraced Garden", new THREE.Vector3(-6, 5.5, 2));

        // Start Loop
        window.addEventListener('resize', onWindowResize, false);
        animate();
    }

    function createEnvironment() {
        // Ground Plane
        const groundGeo = new THREE.PlaneGeometry(200, 200);
        const groundMesh = new THREE.Mesh(groundGeo, materials.grass);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // Simple Trees
        for(let i=0; i<20; i++) {
            const x = (Math.random() - 0.5) * 100;
            const z = (Math.random() - 0.5) * 100;
            if (Math.abs(x) < 20 && Math.abs(z) < 20) continue; // Clear area for building

            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.7, 3), materials.pine);
            trunk.position.set(x, 1.5, z);

            const foliage = new THREE.Mesh(new THREE.DodecahedronGeometry(2.5), materials.grass);
            foliage.position.set(x, 4, z);

            scene.add(trunk);
            scene.add(foliage);
        }
    }

    function createBuilding() {
        // The structure is 3 tiered floors.
        // We'll group them to make organization easier.
        const buildingGroup = new THREE.Group();
        scene.add(buildingGroup);

        // -- Floor 1 (Main Hall) --
        // Dimensions: 20w x 6h x 12d
        const f1Geo = new THREE.BoxGeometry(20, 6, 12);
        // We need it hollow for the interior view, so we'll build walls instead of a solid block for the first floor.
        // Floor
        const f1Floor = new THREE.Mesh(new THREE.BoxGeometry(20, 0.2, 12), materials.floor);
        f1Floor.position.y = 0.1;
        f1Floor.receiveShadow = true;
        buildingGroup.add(f1Floor);

        // Ceiling F1
        const f1Ceiling = new THREE.Mesh(new THREE.BoxGeometry(20, 0.5, 12), materials.pine);
        f1Ceiling.position.y = 6;
        f1Ceiling.castShadow = true;
        buildingGroup.add(f1Ceiling);

        // Pillars/Structure (Pine Beams)
        const pillarGeo = new THREE.BoxGeometry(1, 6, 1);
        const positions = [
            [-9.5, 3, -5.5], [9.5, 3, -5.5],
            [-9.5, 3, 5.5], [9.5, 3, 5.5],
            [0, 3, -5.5], [0, 3, 5.5] // Center pillars
        ];
        positions.forEach(pos => {
            const pillar = new THREE.Mesh(pillarGeo, materials.pine);
            pillar.position.set(...pos);
            pillar.castShadow = true;
            pillar.receiveShadow = true;
            buildingGroup.add(pillar);
        });

        // Glass Walls (Large Windows)
        // Front Glass
        const glassFront = new THREE.Mesh(new THREE.BoxGeometry(18, 5, 0.2), materials.glass);
        glassFront.position.set(0, 3, 6);
        buildingGroup.add(glassFront);
        // Back Glass
        const glassBack = new THREE.Mesh(new THREE.BoxGeometry(18, 5, 0.2), materials.glass);
        glassBack.position.set(0, 3, -6);
        buildingGroup.add(glassBack);
        // Side Glass
        const glassLeft = new THREE.Mesh(new THREE.BoxGeometry(0.2, 5, 10), materials.glass);
        glassLeft.position.set(-10, 3, 0);
        buildingGroup.add(glassLeft);
        const glassRight = new THREE.Mesh(new THREE.BoxGeometry(0.2, 5, 10), materials.glass);
        glassRight.position.set(10, 3, 0);
        buildingGroup.add(glassRight);

        // -- Floor 2 --
        // Setback to create terrace.
        // Dimensions: 14w x 4h x 8d
        const f2Geo = new THREE.BoxGeometry(14, 4, 8);
        const f2 = new THREE.Mesh(f2Geo, materials.pine); // Simplified solid for upper floors
        f2.position.set(0, 8, 0); // 6 (F1 height) + 2 (half F2 height)
        f2.castShadow = true;
        buildingGroup.add(f2);

        // F2 Windows (Arched implication via texture or simple geometry)
        const f2Win = new THREE.Mesh(new THREE.BoxGeometry(14.2, 2, 6), materials.glass);
        f2Win.position.set(0, 8, 0);
        buildingGroup.add(f2Win);

        // -- Floor 3 --
        // Dimensions: 8w x 3h x 5d
        const f3Geo = new THREE.BoxGeometry(8, 3, 5);
        const f3 = new THREE.Mesh(f3Geo, materials.pine);
        f3.position.set(0, 11.5, 0); // 6 + 4 + 1.5
        f3.castShadow = true;
        buildingGroup.add(f3);

        // -- Copper Roofs/Trim --
        // F3 Roof
        const r3 = new THREE.Mesh(new THREE.ConeGeometry(6, 2, 4), materials.copper);
        r3.rotation.y = Math.PI / 4;
        r3.scale.set(1, 0.5, 1);
        r3.position.set(0, 13.5, 0);
        buildingGroup.add(r3);

        // F2 Terrace (Roof of F1)
        // The F1 ceiling is 20x12, F2 base is 14x8. The difference is the terrace.
        // Let's add greenery scattering on the F1 Roof.
        addTerraceGreenery(buildingGroup, 20, 12, 14, 8, 6); // width1, depth1, width2, depth2, yHeight

        // F3 Terrace (Roof of F2)
        addTerraceGreenery(buildingGroup, 14, 8, 8, 5, 10);

        // -- Interior Details (Main Hall) --
        // Bookshelves & Dynamic Book Placement
        const shelfData = [
            { category: 'Manuals', zPos: -4 },
            { category: 'Science', zPos: -1.5 },
            { category: 'History', zPos: 1 },
            { category: 'Spiritual', zPos: 3.5 },
        ];

        shelfData.forEach(data => {
            const shelf = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 3), materials.pine);
            shelf.position.set(-8, 2, data.zPos);
            shelf.userData = { type: 'shelf', category: data.category };
            buildingGroup.add(shelf);
            clickableObjects.push(shelf);

            const booksOnThisShelf = booksDB.filter(book => book.category === data.category);
            booksOnThisShelf.forEach((bookData, index) => {
                if (index < 3) { // Max 3 books per shelf
                    const bookGeo = new THREE.BoxGeometry(0.5, 0.7, 0.2);
                    const bookMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
                    const bookMesh = new THREE.Mesh(bookGeo, bookMat);

                    bookMesh.position.set(-8, 1 + (index * 0.8), data.zPos);
                    bookMesh.rotation.y = Math.random() * 0.2 - 0.1;

                    bookMesh.userData = { type: 'book', ...bookData };

                    buildingGroup.add(bookMesh);
                    clickableObjects.push(bookMesh);
                }
            });
        });

        // CAD/Maker Stations (Tables)
        // Right side
        for(let i=0; i<3; i++) {
            const tableGroup = new THREE.Group();
            tableGroup.position.set(6, 0, -3 + (i*3.5));

            const tableTopGeo = new THREE.BoxGeometry(3, 0.2, 1.5);
            const tableTopMat = materials.white;
            const tableTop = new THREE.Mesh(tableTopGeo, tableTopMat);
            tableTop.position.y = 1;
            tableGroup.add(tableTop);

            const legs = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1, 1.3), materials.pine);
            legs.position.y = 0.5;
            tableGroup.add(legs);

            // Designate the first table as the "Front Desk"
            if (i === 0) {
                tableTop.userData = { type: 'front_desk' };
                clickableObjects.push(tableTop);
                // Add a small "screen" to indicate interactivity
                const deskScreen = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.1), materials.screen);
                deskScreen.position.set(0, 1.3, 0);
                deskScreen.rotation.x = -0.3;
                tableGroup.add(deskScreen);
            } else {
                 // 3D Printer / Monitor for other stations
                const printer = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), materials.screen);
                printer.position.set(0.8, 1.35, 0);
                tableGroup.add(printer);

                const gantry = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.1), materials.copper);
                gantry.position.set(0.8, 1.35, 0);
                tableGroup.add(gantry);

                const monitor = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.6), materials.screen);
                monitor.position.set(-0.5, 1.3, 0.2);
                monitor.rotation.y = -0.2;
                tableGroup.add(monitor);
            }

            const chair = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.5), materials.pine);
            chair.position.set(-1, 0.25, 0);
            tableGroup.add(chair);

            buildingGroup.add(tableGroup);
        }
    }

    function addTerraceGreenery(group, w1, d1, w2, d2, y) {
        // Simple logic: Place random bushes in the area defined by Rect1 - Rect2
        // We just place randomly and check if inside Rect2 (the upper floor), if so, skip.

        for(let i=0; i<40; i++) {
            const mx = (Math.random() - 0.5) * w1;
            const mz = (Math.random() - 0.5) * d1;

            // Check if inside the inner rectangle (plus a margin)
            if (Math.abs(mx) < (w2/2 + 0.5) && Math.abs(mz) < (d2/2 + 0.5)) continue;

            const bush = new THREE.Mesh(new THREE.DodecahedronGeometry(0.3 + Math.random()*0.3), materials.grass);
            bush.position.set(mx, y + 0.2, mz);
            group.add(bush);
        }

        // Copper railing
        // Not implemented for low poly simplicity, but adds to the "Idea"
    }

    // --- UI & Interaction ---

    function moveCamera(view) {
        let targetPos, targetLookAt;

        // Reset label visibility when moving
        showLabels = false;
        updateLabelVisibility();

        switch(view) {
            case 'front':
                // Exterior Front
                targetPos = { x: 0, y: 5, z: 25 };
                targetLookAt = { x: 0, y: 5, z: 0 };
                break;
            case 'aerial':
                // Exterior Aerial
                targetPos = { x: 25, y: 25, z: 25 };
                targetLookAt = { x: 0, y: 5, z: 0 };
                break;
            case 'hall':
                // Main Hall Interior
                targetPos = { x: 0, y: 3, z: 10 }; // Just entering the door
                targetLookAt = { x: 0, y: 3, z: -10 }; // Looking back
                break;
            case 'station':
                // Maker/CAD Station Close-up
                targetPos = { x: 7, y: 2.5, z: 2 };
                targetLookAt = { x: 6, y: 1.5, z: -3 }; // Looking at the tables
                break;
        }

        // Animate Camera
        new TWEEN.Tween(camera.position)
            .to(targetPos, 1500)
            .easing(TWEEN.Easing.Cubic.InOut)
            .start();

        new TWEEN.Tween(controls.target)
            .to(targetLookAt, 1500)
            .easing(TWEEN.Easing.Cubic.InOut)
            .onUpdate(() => controls.update())
            .start();

        // Highlight active button
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${view}`).classList.add('active');
    }

    // --- Label System ---

    function createLabel(text, position) {
        const div = document.createElement('div');
        div.className = 'label';
        div.textContent = text;
        document.getElementById('labels-container').appendChild(div);
        labels.push({ div, position });
    }

    function toggleLabels() {
        showLabels = !showLabels;
        const btn = document.getElementById('btn-labels');
        btn.textContent = showLabels ? "Hide Callouts" : "Material Callouts";
        if(showLabels) btn.classList.add('active');
        else btn.classList.remove('active');
        updateLabelVisibility();
    }

    function updateLabelVisibility() {
        labels.forEach(l => {
            if (showLabels) l.div.classList.add('visible');
            else l.div.classList.remove('visible');
        });
    }

    function updateLabels() {
        if(!showLabels) return;

        labels.forEach(label => {
            const screenPos = label.position.clone();
            screenPos.project(camera);

            const x = (screenPos.x * .5 + .5) * window.innerWidth;
            const y = (-(screenPos.y * .5) + .5) * window.innerHeight;

            // Only show if in front of camera
            if(screenPos.z < 1) {
                label.div.style.transform = `translate(-50%, -100%) translate(${x}px, ${y-10}px)`;
                label.div.style.display = 'block';
            } else {
                label.div.style.display = 'none';
            }
        });
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        controls.update();
        updateLabels();
        renderer.render(scene, camera);
    }

    // Init
    init();

    // --- Raycasting for Book Selection ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onMouseClick(event) {
        // Calculate mouse position in normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        // Update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // Calculate objects intersecting the picking ray
        const intersects = raycaster.intersectObjects(clickableObjects);

        if (intersects.length > 0) {
            const selectedObject = intersects[0].object;
            if (selectedObject.userData.type === 'book') {
                showBookInfo(selectedObject.userData);
            } else if (selectedObject.userData.type === 'shelf') {
                showShelfIndex(selectedObject.userData.category);
            } else if (selectedObject.userData.type === 'front_desk') {
                showFrontDeskIndex();
            }
        }
    }

    function showFrontDeskIndex() {
        const panel = document.getElementById('front-desk-panel');
        const bookListDiv = document.getElementById('front-desk-book-list');
        bookListDiv.innerHTML = ''; // Clear previous list

        const categories = [...new Set(booksDB.map(book => book.category))];
        categories.forEach(category => {
            const categoryHeader = document.createElement('h4');
            categoryHeader.textContent = category;
            categoryHeader.style.marginTop = '10px';
            bookListDiv.appendChild(categoryHeader);

            const bookList = document.createElement('ul');
            const booksInCategory = booksDB.filter(book => book.category === category);
            booksInCategory.forEach(book => {
                const li = document.createElement('li');
                li.textContent = `${book.title} by ${book.author}`;
                bookList.appendChild(li);
            });
            bookListDiv.appendChild(bookList);
        });

        panel.style.display = 'block';
    }

    function hideFrontDeskIndex() {
        document.getElementById('front-desk-panel').style.display = 'none';
    }

    function showShelfIndex(category) {
        const panel = document.getElementById('shelf-index-panel');
        document.getElementById('shelf-category').textContent = `${category} Shelf`;
        const bookList = document.getElementById('shelf-book-list');
        bookList.innerHTML = ''; // Clear previous list
        const booksOnShelf = booksDB.filter(book => book.category === category);
        booksOnShelf.forEach(book => {
            const li = document.createElement('li');
            li.textContent = book.title;
            bookList.appendChild(li);
        });
        panel.style.display = 'block';
    }

    function hideShelfIndex() {
        document.getElementById('shelf-index-panel').style.display = 'none';
    }

    function showBookInfo(bookData) {
        document.getElementById('book-title').textContent = bookData.title;
        document.getElementById('book-author').textContent = bookData.author;
        document.getElementById('book-description').textContent = bookData.description;
        document.getElementById('book-cover').src = bookData.coverImage;
        document.getElementById('download-btn').onclick = () => onDownloadClick(bookData);
        document.getElementById('donate-btn').onclick = () => onDonateClick(bookData);
        document.getElementById('book-info-panel').style.display = 'block';
    }

    function hideBookInfo() {
        document.getElementById('book-info-panel').style.display = 'none';
    }

    window.addEventListener('click', onMouseClick, false);

    function onDownloadClick(bookData) {
        console.log(`DOWNLOAD event: User downloaded "${bookData.title}". Logging to analytics.`);
        window.open(bookData.content, '_blank');
        // In a real app, you would also update the database here.
    }

    function onDonateClick(bookData) {
        console.log(`DONATION event: User clicked donate for "${bookData.title}".`);
        window.open(bookData.donationLink, '_blank');
    }

</script>
<pre>
<code>
// --- Pseudocode Plan for a Real In-Game Library ---

// I. CORE DATA STRUCTURES

// Book:
//  - id (unique identifier, e.g., ISBN or UUID)
//  - title
//  - author
//  - description
//  - content (URL to a PDF, EPUB, or plain text file)
//  - coverImage (URL to an image)
//  - category/tags (e.g., "Permaculture," "Fiction," "History")
//  - downloadCount (integer)
//  - uploader (user ID)
//  - donationLink (URL to a payment processor)

// User:
//  - id (unique identifier)
//  - username
//  - downloadedBooks (list of book IDs)
//  - donatedAmount (float)

// LibraryLog:
//  - timestamp
//  - eventType (e.g., "DOWNLOAD", "DONATION", "UPLOAD")
//  - userId
//  - bookId (if applicable)
//  - details (e.g., amount donated, file size)

// II. CORE FUNCTIONALITY

// function initializeLibrary():
//  - Fetch all book data from a database (e.g., Firebase, Supabase, or a simple JSON file).
//  - For each book, create a 3D object in the scene (e.g., a simple box with the book's cover as a texture).
//  - Position the book objects on the shelves in the 3D world.
//  - Add event listeners to each book object for user interaction (e.g., clicks).

// function onBookClick(book):
//  - Display a UI panel with the book's details (title, author, description, coverImage).
//  - Show a "Download" button.
//  - Show a "Donate" button with the book's donationLink.

// function onDownloadClick(book):
//  - Increment book.downloadCount.
//  - Log the download event in the LibraryLog.
//  - Initiate the file download (e.g., window.open(book.content)).
//  - Update the book's data in the database.

// function onDonateClick(book):
//  - Open the book.donationLink in a new tab.
//  - (Optional) Use a payment processor's API to track successful donations.
//  - If a donation is successful, log the event in the LibraryLog and update the user's donatedAmount.

// III. USER INTERACTION

// - Implement a raycasting system to detect when a user clicks on a book object in the 3D scene.
// - Create a 2D UI overlay (using HTML and CSS) to display book information and buttons.
// - Implement a search/filter system to allow users to find books by title, author, or category.

// IV. BACKEND & DATA PERSISTENCE

// - Set up a simple backend server (e.g., using Node.js and Express) to handle database operations.
// - Choose a database to store the book, user, and log data.
// - Implement API endpoints for:
//  - GET /books (fetch all books)
//  - PUT /books/:id (update a book's download count)
//  - POST /logs (create a new log entry)

// V. INITIALIZATION

// - When the page loads, call initializeLibrary().
</code>
</pre>
</body>
</html>
